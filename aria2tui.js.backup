#!/usr/bin/env node
'use strict';

/**
 * aria2tui - a dependency-free terminal UI to quickly set aria2c parameters
 * and then execute the aria2c command.
 */

const os = require('node:os');
const fs = require('node:fs');
const path = require('node:path');
const { spawn } = require('node:child_process');

const ANSI = {
  clear: '\x1b[2J',
  home: '\x1b[H',
  hideCursor: '\x1b[?25l',
  showCursor: '\x1b[?25h',
  reset: '\x1b[0m',
  inverse: '\x1b[7m',
  dim: '\x1b[2m',
  bold: '\x1b[1m',
  underline: '\x1b[4m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
  white: '\x1b[37m',
  gray: '\x1b[90m',
  brightRed: '\x1b[91m',
  brightGreen: '\x1b[92m',
  brightYellow: '\x1b[93m',
  brightBlue: '\x1b[94m',
  brightMagenta: '\x1b[95m',
  brightCyan: '\x1b[96m',
  brightWhite: '\x1b[97m',
  // Terminal Green theme (from UI/UX skill)
  terminalGreen: '\x1b[92m',  // #00FF41 equivalent
  primaryAccent: '\x1b[96m',  // Bright cyan for primary actions
  secondaryText: '\x1b[90m',  // Gray for secondary info
  successGreen: '\x1b[92m',   // Bright green for success
  warningYellow: '\x1b[93m',  // Bright yellow for warnings
  errorRed: '\x1b[91m',       // Bright red for errors
  // Background combinations
  bgDark: '\x1b[48;5;235m',   // Dark background
  bgHighlight: '\x1b[48;5;238m',  // Highlighted background
};

function stripAnsi(s) {
  return s.replace(/\x1b\[[0-9;?]*[a-zA-Z]/g, '');
}

function padRight(s, w) {
  const raw = stripAnsi(s);
  if (raw.length >= w) return s;
  return s + ' '.repeat(w - raw.length);
}

function trunc(s, w) {
  const raw = stripAnsi(s);
  if (raw.length <= w) return s;
  return raw.slice(0, Math.max(0, w - 1)) + 'â€¦';
}

function drawSeparator(width, char = 'â”€', style = 'normal') {
  const line = char.repeat(Math.max(0, width));
  if (style === 'bold') return ANSI.bold + line + ANSI.reset;
  if (style === 'dim') return ANSI.secondaryText + line + ANSI.reset;
  if (style === 'accent') return ANSI.primaryAccent + line + ANSI.reset;
  return line;
}

function drawGroupHeader(title, width, style = 'default') {
  if (width < 10) return trunc(title, width);

  if (style === 'main') {
    // Simple bold header with separator
    return ANSI.bold + ANSI.primaryAccent + title + ANSI.reset;
  } else if (style === 'section') {
    // Section with arrow prefix
    return ANSI.terminalGreen + 'â–¸ ' + ANSI.bold + title + ANSI.reset;
  } else {
    // Default style
    const leftPad = 1;
    const rightFill = Math.max(0, width - leftPad - stripAnsi(title).length - 1);
    return ANSI.cyan + ANSI.bold + 'â”€' + title + 'â”€'.repeat(rightFill) + ANSI.reset;
  }
}

function drawBox(lines, width) {
  const boxed = [];
  const innerWidth = width - 4;
  for (const line of lines) {
    const content = trunc(line, innerWidth);
    const padding = ' '.repeat(Math.max(0, innerWidth - stripAnsi(content).length));
    boxed.push(ANSI.secondaryText + 'â”‚ ' + ANSI.reset + content + padding + ANSI.secondaryText + ' â”‚' + ANSI.reset);
  }
  return boxed;
}

function safeWrite(s) {
  process.stdout.write(s);
}

function getTerminalSize() {
  return { cols: process.stdout.columns || 80, rows: process.stdout.rows || 24 };
}

function parseArgs(argv) {
  const args = {
    bin: process.env.ARIA2_BIN || 'aria2c',
    config: process.env.ARIA2TUI_CONFIG || path.join(os.homedir(), '.aria2tui.json'),
    history: process.env.ARIA2TUI_HISTORY || path.join(os.homedir(), '.aria2tui_history.json'),
    help: false,
  };
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a === '--bin' && argv[i + 1]) args.bin = argv[++i];
    else if (a === '--config' && argv[i + 1]) args.config = argv[++i];
    else if (a === '--help' || a === '-h') args.help = true;
  }
  return args;
}

function usage() {
  return [
    'aria2tui - ç»ˆç«¯ç•Œé¢ç”Ÿæˆå¹¶æ‰§è¡Œ aria2c å‘½ä»¤',
    '',
    'Usage:',
    '  ./aria2tui.js [--bin aria2c] [--config /path/to/config.json]',
    '',
    'Env:',
    '  ARIA2_BIN          aria2c binary path/name (default: aria2c)',
    '  ARIA2TUI_CONFIG    config file path (default: ~/.aria2tui.json)',
    '',
    'Keys:',
    '  â†‘/â†“(j/k) é€‰æ‹©   Enter ç¼–è¾‘/æ‰§è¡Œ   Space å¼€å…³',
    '  u URIs  t ç§å­  p é¢„è§ˆ  r è¿è¡Œ  s ä¿å­˜  q é€€å‡º  Esc è¿”å›',
    '',
  ].join('\n');
}

function readJson(filePath) {
  try {
    const text = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(text);
  } catch {
    return null;
  }
}

function writeJson(filePath, obj) {
  fs.writeFileSync(filePath, JSON.stringify(obj, null, 2) + '\n', 'utf8');
}

function shellEscape(arg) {
  if (arg === '') return "''";
  return `'${String(arg).replace(/'/g, `'\"'\"'`)}'`;
}

function formatValue(v) {
  if (typeof v === 'boolean') return v ? 'true' : 'false';
  if (v === null || v === undefined) return '';
  return String(v);
}

function parseShellWords(input) {
  const s = String(input || '');
  const out = [];
  let cur = '';
  let i = 0;
  let inSingle = false;
  let inDouble = false;
  while (i < s.length) {
    const ch = s[i];
    if (!inDouble && ch === "'" && !inSingle) {
      inSingle = true;
      i++;
      continue;
    }
    if (inSingle && ch === "'") {
      inSingle = false;
      i++;
      continue;
    }
    if (!inSingle && ch === '"' && !inDouble) {
      inDouble = true;
      i++;
      continue;
    }
    if (inDouble && ch === '"') {
      inDouble = false;
      i++;
      continue;
    }
    if (!inSingle && !inDouble && /\s/.test(ch)) {
      if (cur.length > 0) out.push(cur);
      cur = '';
      while (i < s.length && /\s/.test(s[i])) i++;
      continue;
    }
    if (!inSingle && ch === '\\' && i + 1 < s.length) {
      cur += s[i + 1];
      i += 2;
      continue;
    }
    cur += ch;
    i++;
  }
  if (cur.length > 0) out.push(cur);
  return out;
}

function buildArgsFromConfig(cfg) {
  const args = [];
  const pushKV = (flag, value) => {
    if (value === '' || value === null || value === undefined) return;
    args.push(flag, String(value));
  };
  const pushBool = (flag, enabled) => {
    if (enabled) args.push(flag);
  };
  const pushLongKV = (flag, value) => {
    if (value === '' || value === null || value === undefined) return;
    args.push(`${flag}=${String(value)}`);
  };

  pushKV('-d', cfg.dir);
  pushKV('-o', cfg.out);
  pushBool('-c', !!cfg.continue);
  pushKV('-j', cfg.maxConcurrentDownloads);
  pushKV('-s', cfg.split);
  pushKV('-x', cfg.maxConnectionPerServer);
  pushLongKV('--max-download-limit', cfg.maxDownloadLimit);
  pushLongKV('--max-upload-limit', cfg.maxUploadLimit);
  pushLongKV('--file-allocation', cfg.fileAllocation);
  pushLongKV('--check-certificate', cfg.checkCertificate ? 'true' : 'false');
  pushLongKV('--enable-mmap', cfg.enableMmap ? 'true' : 'false');
  pushLongKV('--follow-torrent', cfg.followTorrent ? 'true' : 'false');
  pushLongKV('--seed-time', cfg.seedTime);
  pushKV('-U', cfg.userAgent);

  if (cfg.torrentFile) args.push('-T', cfg.torrentFile);
  if (cfg.inputFile) args.push('--input-file', cfg.inputFile);

  const extra = parseShellWords(cfg.extraArgs || '');
  args.push(...extra);

  const uris = Array.isArray(cfg.uris) ? cfg.uris.filter(Boolean) : [];
  args.push(...uris);

  return args;
}

async function main() {
  const args = parseArgs(process.argv);
  if (args.help) {
    // eslint-disable-next-line no-console
    console.log(usage());
    process.exit(0);
  }

  if (!process.stdin.isTTY || !process.stdout.isTTY) {
    // eslint-disable-next-line no-console
    console.error('This tool needs a TTY (run in a real terminal).');
    process.exit(1);
  }

  const defaults = {
    uris: [],
    dir: path.join(os.homedir(), 'Downloads'),
    out: '',
    continue: true,
    maxConcurrentDownloads: 5,
    split: 16,
    maxConnectionPerServer: 16,
    maxDownloadLimit: '',
    maxUploadLimit: '',
    fileAllocation: 'none',
    checkCertificate: true,
    enableMmap: true,
    followTorrent: true,
    seedTime: 0,
    userAgent: '',
    torrentFile: '',
    inputFile: '',
    extraArgs: '',
  };

  const loaded = readJson(args.config);
  const cfg = { ...defaults, ...(loaded && typeof loaded === 'object' ? loaded : {}) };

  // å†å²è®°å½•åŠŸèƒ½
  let history = [];
  function loadHistory() {
    const data = readJson(args.history);
    if (Array.isArray(data)) {
      history = data.slice(0, 20); // æœ€å¤šä¿ç•™ 20 æ¡
    }
  }

  function saveHistory() {
    try {
      writeJson(args.history, history);
    } catch (e) {
      // å¿½ç•¥ä¿å­˜å¤±è´¥
    }
  }

  function addToHistory(config, status = 'pending') {
    const entry = {
      id: Date.now(),
      timestamp: new Date().toISOString(),
      config: { ...config },
      status, // pending | completed | failed
      filename: config.out || 'unknown',
      url: Array.isArray(config.uris) && config.uris.length > 0 ? config.uris[0] : config.torrentFile || config.inputFile || '',
    };

    // ç§»é™¤ç›¸åŒ URL çš„æ—§è®°å½•
    history = history.filter(h => h.url !== entry.url);
    history.unshift(entry);
    history = history.slice(0, 20);
    saveHistory();
  }

  function updateHistoryStatus(id, status) {
    const entry = history.find(h => h.id === id);
    if (entry) {
      entry.status = status;
      saveHistory();
    }
  }

  loadHistory();

  const fields = [
    // è¾“å…¥æº
    { key: 'uris', label: 'ä¸‹è½½é“¾æ¥ (u)', type: 'list', group: 'input', description: 'è®¾ç½®ä¸‹è½½ URLï¼Œå¯ä»¥è®¾ç½®å¤šä¸ªï¼Œç©ºæ ¼åˆ†éš”', hint: 'ç©ºæ ¼åˆ†éš”' },
    { key: 'inputFile', label: 'é€‰æ‹©æ–‡ä»¶ (t)', type: 'file', group: 'input', description: 'é€‰æ‹©ç§å­æ–‡ä»¶(.torrent)ã€Metalinkæ–‡ä»¶(.metalink)æˆ–è¾“å…¥æ–‡ä»¶', hint: 'æ–‡ä»¶è·¯å¾„' },

    // ä¿å­˜è®¾ç½®
    { key: 'dir', label: 'ä¿å­˜ç›®å½• (-d)', type: 'string', group: 'save', description: 'è®¾ç½®æ–‡ä»¶ä¿å­˜ç›®å½•ï¼Œç•™ç©ºåˆ™ä¿å­˜åˆ°å½“å‰ç›®å½•', hint: 'ç»å¯¹æˆ–ç›¸å¯¹è·¯å¾„' },
    { key: 'out', label: 'è¾“å‡ºæ–‡ä»¶å (-o)', type: 'string', group: 'save', description: 'æŒ‡å®šè¾“å‡ºæ–‡ä»¶çš„åç§°ï¼ˆä»…é€‚ç”¨äºå•æ–‡ä»¶ä¸‹è½½ï¼‰', hint: 'æ–‡ä»¶å' },
    { key: 'continue', label: 'æ–­ç‚¹ç»­ä¼  (-c)', type: 'bool', group: 'save', description: 'æ”¯æŒæ–­ç‚¹ç»­ä¼ ï¼Œç»§ç»­ä¹‹å‰æœªå®Œæˆçš„ä¸‹è½½', hint: '' },

    // æ€§èƒ½ä¼˜åŒ–
    { key: 'maxConcurrentDownloads', label: 'å¹¶å‘ä»»åŠ¡ (-j)', type: 'number', group: 'performance', description: 'åŒæ—¶è¿›è¡Œçš„ä¸‹è½½ä»»åŠ¡æ•°é‡', hint: 'æ¨è 1-10' },
    { key: 'split', label: 'åˆ†ç‰‡æ•° (-s)', type: 'number', group: 'performance', description: 'å•ä¸ªæ–‡ä»¶çš„åˆ†ç‰‡æ•°é‡ï¼Œæå‡ä¸‹è½½é€Ÿåº¦', hint: 'æ¨è 16-64' },
    { key: 'maxConnectionPerServer', label: 'å•æœè¿æ¥ (-x)', type: 'number', group: 'performance', description: 'å•ä¸ªæœåŠ¡å™¨çš„æœ€å¤§è¿æ¥æ•°', hint: 'æ¨è 1-16' },
    { key: 'fileAllocation', label: 'æ–‡ä»¶é¢„åˆ†é…', type: 'enum', options: ['none', 'prealloc', 'trunc', 'falloc'], group: 'performance', description: 'æ–‡ä»¶é¢„åˆ†é…æ–¹å¼ï¼Œå½±å“ç£ç›˜ç©ºé—´å ç”¨å’Œæ€§èƒ½', hint: '' },
    { key: 'enableMmap', label: 'å¯ç”¨ mmap', type: 'bool', group: 'performance', description: 'ä½¿ç”¨å†…å­˜æ˜ å°„ I/Oï¼Œå¯èƒ½æå‡æ€§èƒ½', hint: '' },

    // é™é€Ÿæ§åˆ¶
    { key: 'maxDownloadLimit', label: 'ä¸‹è½½é™é€Ÿ', type: 'string', group: 'limit', description: 'é™åˆ¶æœ€å¤§ä¸‹è½½é€Ÿåº¦ï¼ˆç•™ç©ºä¸ºä¸é™é€Ÿï¼‰', hint: 'å¦‚ 10M, 1G' },
    { key: 'maxUploadLimit', label: 'ä¸Šä¼ é™é€Ÿ', type: 'string', group: 'limit', description: 'é™åˆ¶æœ€å¤§ä¸Šä¼ é€Ÿåº¦ï¼ˆç”¨äº BTï¼‰', hint: 'å¦‚ 1M, 500K' },

    // ç§å­è®¾ç½®
    { key: 'followTorrent', label: 'è·Ÿéšç§å­', type: 'bool', group: 'torrent', description: 'ä¸‹è½½ç§å­æ–‡ä»¶åè‡ªåŠ¨å¼€å§‹ä¸‹è½½ç§å­å†…å®¹', hint: '' },
    { key: 'seedTime', label: 'åšç§æ—¶é—´(åˆ†é’Ÿ)', type: 'number', group: 'torrent', description: 'BT ä¸‹è½½å®Œæˆååšç§æ—¶é•¿ï¼Œ0 è¡¨ç¤ºä¸åšç§', hint: 'åˆ†é’Ÿ' },

    // é«˜çº§é€‰é¡¹
    { key: 'userAgent', label: 'User-Agent (-U)', type: 'string', group: 'advanced', description: 'è‡ªå®šä¹‰ HTTP User-Agent å­—ç¬¦ä¸²', hint: '' },
    { key: 'checkCertificate', label: 'æ ¡éªŒè¯ä¹¦', type: 'bool', group: 'advanced', description: 'HTTPS è¿æ¥æ—¶éªŒè¯æœåŠ¡å™¨è¯ä¹¦', hint: '' },
    { key: 'extraArgs', label: 'é¢å¤–å‚æ•°', type: 'string', group: 'advanced', description: 'å…¶ä»– aria2c å‘½ä»¤è¡Œå‚æ•°ï¼ŒåŸæ ·æ‹¼æ¥', hint: 'åŸæ ·æ‹¼æ¥' },

    // æ“ä½œ
    { key: '__run__', label: ANSI.green + 'æ‰§è¡Œ aria2c (r/Enter)' + ANSI.reset, type: 'action', group: 'action', description: 'æ‰§è¡Œ aria2c å‘½ä»¤å¼€å§‹ä¸‹è½½', hint: '' },
  ];

  const state = {
    mode: 'list', // list | prompt | preview | filebrowser
    view: 'history', // history | groups | fields
    currentGroup: null, // å½“å‰æ‰€åœ¨çš„åˆ†ç»„
    selected: 0,
    prompt: { label: '', hint: '', value: '', targetKey: '', validation: { valid: true, message: '' } },
    inlineEdit: null, // å½“å‰å†…è”ç¼–è¾‘çš„å­—æ®µ key
    inlineEditValue: '', // å†…è”ç¼–è¾‘çš„å€¼
    fileBrowser: { targetKey: '', currentPath: '', items: [], selected: 0 }, // æ–‡ä»¶æµè§ˆå™¨çŠ¶æ€
    message: '',
    messageType: 'info', // info | success | warning | error
    messageAt: 0,
    inputSourceSet: false, // æ˜¯å¦å·²è®¾ç½®è¾“å…¥æº
    currentHistoryId: null, // å½“å‰æ¢å¤çš„å†å²è®°å½• ID
  };

  function setMessage(msg, type = 'info') {
    const icons = {
      success: ANSI.green + 'âœ“ ' + ANSI.reset,
      warning: ANSI.yellow + 'âš  ' + ANSI.reset,
      error: ANSI.red + 'âœ— ' + ANSI.reset,
      info: '',
    };
    state.message = (icons[type] || '') + msg;
    state.messageType = type;
    state.messageAt = Date.now();
  }

  function checkInputSource() {
    const hasUris = Array.isArray(cfg.uris) && cfg.uris.length > 0;
    const hasInputFile = cfg.inputFile && cfg.inputFile.trim() !== '';
    state.inputSourceSet = hasUris || hasInputFile;
    return state.inputSourceSet;
  }

  const groupDefinitions = [
    { key: 'input', name: 'è¾“å…¥æº', icon: 'ğŸ”—', description: 'è®¾ç½®ä¸‹è½½ URLã€ç§å­æ–‡ä»¶æˆ–è¾“å…¥æ–‡ä»¶', required: true },
    { key: 'save', name: 'ä¿å­˜è®¾ç½®', icon: 'ğŸ’¾', description: 'è®¾ç½®ä¿å­˜ç›®å½•ã€æ–‡ä»¶åå’Œæ–­ç‚¹ç»­ä¼ ' },
    { key: 'performance', name: 'æ€§èƒ½ä¼˜åŒ–', icon: 'âš¡', description: 'è°ƒæ•´å¹¶å‘ã€åˆ†ç‰‡ã€è¿æ¥æ•°ç­‰æ€§èƒ½å‚æ•°' },
    { key: 'limit', name: 'é™é€Ÿæ§åˆ¶', icon: 'ğŸš¦', description: 'é™åˆ¶ä¸‹è½½å’Œä¸Šä¼ é€Ÿåº¦' },
    { key: 'torrent', name: 'ç§å­è®¾ç½®', icon: 'ğŸŒ±', description: 'BT ä¸‹è½½ç›¸å…³è®¾ç½®' },
    { key: 'advanced', name: 'é«˜çº§é€‰é¡¹', icon: 'âš™ï¸', description: 'User-Agentã€è¯ä¹¦æ ¡éªŒç­‰é«˜çº§é€‰é¡¹' },
    { key: 'action', name: 'æ‰§è¡Œä¸‹è½½', icon: 'â–¶ï¸', description: 'é¢„è§ˆå’Œæ‰§è¡Œ aria2c å‘½ä»¤' },
  ];

  function getGroupSummary(groupKey) {
    const groupFields = fields.filter(f => f.group === groupKey);
    const setCount = groupFields.filter(f => {
      const val = cfg[f.key];
      if (f.type === 'list') return Array.isArray(val) && val.length > 0;
      if (f.type === 'bool') return true; // bool æ€»æ˜¯æœ‰å€¼
      if (f.type === 'action') return false;
      return val !== '' && val !== null && val !== undefined;
    }).length;
    const totalCount = groupFields.filter(f => f.type !== 'action').length;
    return `${setCount}/${totalCount}`;
  }

  function buildExpandedRows() {
    const groupNames = {
      input: 'è¾“å…¥æº',
      save: 'ä¿å­˜è®¾ç½®',
      performance: 'æ€§èƒ½ä¼˜åŒ–',
      limit: 'é™é€Ÿæ§åˆ¶',
      torrent: 'ç§å­è®¾ç½®',
      advanced: 'é«˜çº§é€‰é¡¹',
      action: 'æ“ä½œ',
    };
    const expandedRows = [];
    let currentGroup = null;
    for (const f of fields) {
      if (f.group !== currentGroup) {
        currentGroup = f.group;
        const groupTitle = groupNames[currentGroup] || currentGroup;
        expandedRows.push({ type: 'group', title: groupTitle });
      }
      expandedRows.push({ type: 'field', field: f });
    }
    return expandedRows;
  }

  function getFieldAtIndex(expandedRows, index) {
    if (index < 0 || index >= expandedRows.length) return null;
    const row = expandedRows[index];
    return row.type === 'field' ? row.field : null;
  }

  function renderList() {
    if (state.view === 'history') {
      renderHistoryView();
    } else if (state.view === 'groups') {
      renderGroupsView();
    } else {
      renderFieldsView();
    }
  }

  function renderHistoryView() {
    const { cols, rows } = getTerminalSize();
    const now = Date.now();
    const msg = state.message && now - state.messageAt < 4000 ? state.message : '';

    // Simple header
    const header = ANSI.bold + ANSI.primaryAccent + 'ARIA2TUI - ä¸‹è½½å†å²' + ANSI.reset;
    const helpBar = '  ' + ANSI.secondaryText + 'â†‘â†“' + ANSI.reset + ' é€‰æ‹©  ' +
                    ANSI.terminalGreen + 'Enter' + ANSI.reset + ' æ¢å¤  ' +
                    ANSI.terminalGreen + 'n' + ANSI.reset + ' æ–°å»º  ' +
                    ANSI.terminalGreen + 'd' + ANSI.reset + ' åˆ é™¤  ' +
                    ANSI.secondaryText + 'q' + ANSI.reset + ' é€€å‡º';

    const lines = [];
    lines.push(header);
    lines.push(helpBar);
    lines.push(drawSeparator(cols, 'â”€', 'dim'));

    if (history.length === 0) {
      lines.push('');
      lines.push(ANSI.secondaryText + '  æš‚æ— ä¸‹è½½å†å²' + ANSI.reset);
      lines.push('');
      lines.push(ANSI.primaryAccent + '  âš¡ æŒ‰ ' + ANSI.bold + 'n' + ANSI.reset + ANSI.primaryAccent + ' å¼€å§‹æ–°çš„ä¸‹è½½' + ANSI.reset);
    } else {
      lines.push('');

      // "æ–°å»ºä¸‹è½½" option with simple styling
      const newDownloadText = ANSI.terminalGreen + 'âš¡ æ–°å»ºä¸‹è½½' + ANSI.reset;
      if (state.selected === 0) {
        lines.push(ANSI.primaryAccent + ' â–¸ ' + ANSI.bold + newDownloadText + ANSI.reset);
      } else {
        lines.push('   ' + newDownloadText);
      }

      lines.push('');

      // Display history with improved visual hierarchy
      for (let i = 0; i < Math.min(history.length, 15); i++) {
        const h = history[i];
        const date = new Date(h.timestamp);
        const timeStr = `${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;

        let statusIcon = '';
        let statusColor = '';
        if (h.status === 'completed') {
          statusIcon = 'âœ“';
          statusColor = ANSI.successGreen;
        } else if (h.status === 'failed') {
          statusIcon = 'âœ—';
          statusColor = ANSI.errorRed;
        } else {
          statusIcon = 'â‹¯';
          statusColor = ANSI.warningYellow;
        }

        const filename = trunc(h.filename || 'unknown', 40);
        const url = trunc(h.url, Math.max(30, cols - 70));

        if (state.selected === i + 1) {
          // Selected item with arrow indicator
          lines.push(ANSI.primaryAccent + ' â–¸ ' + ANSI.reset + statusColor + statusIcon + ANSI.reset + ' ' + ANSI.bold + filename + ANSI.reset + ' ' + ANSI.secondaryText + timeStr + ANSI.reset);
          lines.push('     ' + ANSI.secondaryText + url + ANSI.reset);
        } else {
          const content = `   ${statusColor}${statusIcon}${ANSI.reset} ${filename} ${ANSI.secondaryText}${timeStr}${ANSI.reset}`;
          lines.push(content);
        }
      }
    }

    // Bottom help based on selection
    lines.push('');
    lines.push(drawSeparator(cols, 'â”€', 'dim'));

    if (state.selected === 0) {
      lines.push(ANSI.secondaryText + '  åˆ›å»ºæ–°çš„ä¸‹è½½ä»»åŠ¡' + ANSI.reset);
    } else if (state.selected > 0 && state.selected <= history.length) {
      const h = history[state.selected - 1];
      if (h.status === 'completed') {
        lines.push(ANSI.warningYellow + '  âš  æ­¤æ–‡ä»¶å·²ä¸‹è½½å®Œæˆï¼ŒæŒ‰ Enter é‡æ–°ä¸‹è½½' + ANSI.reset);
      } else if (h.status === 'failed') {
        lines.push(ANSI.primaryAccent + '  å¯ä»¥å°è¯•é‡æ–°ä¸‹è½½æ­¤æ–‡ä»¶' + ANSI.reset);
      } else {
        lines.push(ANSI.primaryAccent + '  ç»§ç»­æœªå®Œæˆçš„ä¸‹è½½' + ANSI.reset);
      }
    }

    // Message bar
    if (msg) {
      lines.push('');
      const msgColor = state.messageType === 'error' ? ANSI.errorRed :
                      state.messageType === 'success' ? ANSI.successGreen :
                      ANSI.primaryAccent;
      lines.push(msgColor + '  â„¹ ' + msg + ANSI.reset);
    }

    safeWrite(ANSI.clear + ANSI.home);
    safeWrite(lines.join('\n'));
  }

  function renderGroupsView() {
    const { cols, rows } = getTerminalSize();
    const now = Date.now();
    const msg = state.message && now - state.messageAt < 4000 ? state.message : '';

    checkInputSource();

    // Simple header
    const header = ANSI.bold + ANSI.primaryAccent + 'ARIA2TUI - é…ç½®å‘å¯¼' + ANSI.reset;
    const helpBar = '  ' + ANSI.secondaryText + 'â†‘â†“' + ANSI.reset + ' é€‰æ‹©  ' +
                    ANSI.terminalGreen + 'Enter' + ANSI.reset + ' è¿›å…¥  ' +
                    ANSI.terminalGreen + 'u' + ANSI.reset + ' URI  ' +
                    ANSI.terminalGreen + 't' + ANSI.reset + ' Torrent  ' +
                    ANSI.terminalGreen + 'p' + ANSI.reset + ' é¢„è§ˆ  ' +
                    ANSI.terminalGreen + 'r' + ANSI.reset + ' è¿è¡Œ  ' +
                    ANSI.secondaryText + 's' + ANSI.reset + ' ä¿å­˜  ' +
                    ANSI.secondaryText + 'q' + ANSI.reset + ' é€€å‡º';

    const lines = [];
    lines.push(header);
    lines.push(helpBar);
    lines.push(drawSeparator(cols, 'â”€', 'dim'));
    lines.push('');

    // Display groups with enhanced styling
    for (let i = 0; i < groupDefinitions.length; i++) {
      const group = groupDefinitions[i];
      const isLocked = group.key !== 'input' && !state.inputSourceSet;
      const isSelected = i === state.selected;

      let statusIcon = '';
      let statusColor = '';
      if (group.key === 'input') {
        statusIcon = state.inputSourceSet ? 'âœ“' : '!';
        statusColor = state.inputSourceSet ? ANSI.successGreen : ANSI.warningYellow;
      } else if (group.key === 'action') {
        statusIcon = 'â–¶';
        statusColor = state.inputSourceSet ? ANSI.terminalGreen : ANSI.secondaryText;
      } else {
        if (isLocked) {
          statusIcon = 'ğŸ”’';
          statusColor = ANSI.secondaryText;
        } else {
          statusIcon = 'â–¸';
          statusColor = ANSI.primaryAccent;
        }
      }

      const summary = group.key !== 'action' ? ` ${ANSI.secondaryText}[${getGroupSummary(group.key)}]${ANSI.reset}` : '';
      const lockHint = isLocked ? ANSI.secondaryText + ' (éœ€å…ˆè®¾ç½®è¾“å…¥æº)' + ANSI.reset : '';

      if (isSelected) {
        // Selected item with arrow indicator
        const content = ` â–¸ ${statusColor}${statusIcon}${ANSI.reset} ${group.icon} ${ANSI.bold}${group.name}${ANSI.reset}${summary}${lockHint}`;
        lines.push(ANSI.primaryAccent + content.slice(0, 3) + ANSI.reset + content.slice(3));
      } else {
        const content = `   ${statusColor}${statusIcon}${ANSI.reset} ${group.icon} ${group.name}${summary}${lockHint}`;
        lines.push(content);
      }
    }

    // Bottom help with context
    lines.push('');
    lines.push(drawSeparator(cols, 'â”€', 'dim'));

    if (state.selected >= 0 && state.selected < groupDefinitions.length) {
      const group = groupDefinitions[state.selected];
      const isLocked = group.key !== 'input' && !state.inputSourceSet;

      if (isLocked) {
        lines.push(ANSI.warningYellow + '  âš  è¯·å…ˆè®¾ç½®è¾“å…¥æºï¼ˆä¸‹è½½é“¾æ¥/ç§å­æ–‡ä»¶ï¼‰' + ANSI.reset);
      } else {
        lines.push(ANSI.primaryAccent + '  â„¹ ' + group.description + ANSI.reset);
      }
    }

    // Message bar
    if (msg) {
      lines.push('');
      const msgColor = state.messageType === 'error' ? ANSI.errorRed :
                      state.messageType === 'success' ? ANSI.successGreen :
                      ANSI.primaryAccent;
      lines.push(msgColor + '  â„¹ ' + msg + ANSI.reset);
    }

    safeWrite(ANSI.hideCursor + ANSI.clear + ANSI.home);
    safeWrite(lines.join('\n'));
  }

  function renderFieldsView() {
    const { cols, rows } = getTerminalSize();
    const now = Date.now();
    const msg = state.message && now - state.messageAt < 4000 ? state.message : '';

    const currentGroupDef = groupDefinitions.find(g => g.key === state.currentGroup);
    const groupName = currentGroupDef ? currentGroupDef.name : 'æœªçŸ¥åˆ†ç»„';
    const groupIcon = currentGroupDef ? currentGroupDef.icon : '';

    // Simple header with section style
    const header = drawGroupHeader(`${groupIcon} ${groupName}`, cols, 'section');
    const helpBar = '  ' + ANSI.secondaryText + 'â†‘â†“' + ANSI.reset + ' é€‰æ‹©  ' +
                    ANSI.terminalGreen + 'Enter' + ANSI.reset + ' ç¼–è¾‘  ' +
                    ANSI.terminalGreen + 'Space' + ANSI.reset + ' å¼€å…³  ' +
                    ANSI.secondaryText + 'Esc' + ANSI.reset + ' è¿”å›  ' +
                    ANSI.secondaryText + 's' + ANSI.reset + ' ä¿å­˜  ' +
                    ANSI.secondaryText + 'q' + ANSI.reset + ' é€€å‡º';

    const lines = [];
    lines.push(header);
    lines.push(helpBar);
    lines.push(drawSeparator(cols, 'â”€', 'dim'));
    lines.push('');

    // Get current group fields
    const groupFields = fields.filter(f => f.group === state.currentGroup);

    for (let i = 0; i < groupFields.length; i++) {
      const f = groupFields[i];
      const isSelected = i === state.selected;

      let value = '';
      if (f.type === 'list') {
        const list = Array.isArray(cfg[f.key]) ? cfg[f.key] : [];
        value = list.length ? list.join(' ') : '';
      } else if (f.type === 'action') {
        value = '';
      } else {
        value = formatValue(cfg[f.key]);
      }

      if (f.type === 'enum') {
        value = value || '';
      }

      // Enhanced icons with semantic colors
      let icon = '';
      let iconColor = '';
      if (f.type === 'bool') {
        icon = cfg[f.key] ? 'âœ“' : 'âœ—';
        iconColor = cfg[f.key] ? ANSI.successGreen : ANSI.errorRed;
      } else if (f.type === 'action') {
        icon = 'â–¶';
        iconColor = ANSI.terminalGreen;
      } else if (f.type === 'list') {
        icon = 'â‰¡';
        iconColor = ANSI.primaryAccent;
      } else if (f.type === 'number') {
        icon = '#';
        iconColor = ANSI.primaryAccent;
      } else if (f.type === 'enum') {
        icon = 'âš™';
        iconColor = ANSI.primaryAccent;
      } else if (f.type === 'file') {
        icon = 'ğŸ“';
        iconColor = ANSI.primaryAccent;
      } else {
        icon = 'â–¸';
        iconColor = ANSI.secondaryText;
      }

      // Semantic value colors
      let coloredValue = value;
      if (value) {
        if (f.type === 'number') {
          coloredValue = ANSI.primaryAccent + value + ANSI.reset;
        } else if (f.type === 'enum') {
          coloredValue = ANSI.terminalGreen + value + ANSI.reset;
        } else if (f.type === 'bool') {
          coloredValue = '';  // Bool shows in icon
        } else if (f.type !== 'action') {
          coloredValue = ANSI.brightWhite + value + ANSI.reset;
        }
      } else {
        coloredValue = ANSI.secondaryText + '(ç©º)' + ANSI.reset;
      }

      if (isSelected) {
        // Selected item with arrow indicator
        const labelPart = `${iconColor}${icon}${ANSI.reset} ${ANSI.bold}${f.label}${ANSI.reset}`;

        // ç‰¹æ®Šå¤„ç†ï¼šä¸‹è½½é“¾æ¥å­—æ®µæ˜¾ç¤ºå¿«æ·é”®æç¤ºï¼Œå…¶ä»–å­—æ®µæ˜¾ç¤ºå€¼
        if (f.key === 'uris') {
          const shortcutHint = ANSI.secondaryText + ' (u)' + ANSI.reset;
          lines.push(ANSI.primaryAccent + ' â–¸ ' + ANSI.reset + labelPart + shortcutHint);
        } else if (f.key === 'torrentFile') {
          const shortcutHint = ANSI.secondaryText + ' (t)' + ANSI.reset;
          const valuePart = f.type !== 'bool' ? ` ${ANSI.secondaryText}:${ANSI.reset} ${coloredValue}` : '';
          lines.push(ANSI.primaryAccent + ' â–¸ ' + ANSI.reset + labelPart + shortcutHint + valuePart);
        } else {
          const valuePart = f.type !== 'bool' ? ` ${ANSI.secondaryText}:${ANSI.reset} ${coloredValue}` : '';
          lines.push(ANSI.primaryAccent + ' â–¸ ' + ANSI.reset + labelPart + valuePart);
        }

        // å†…è”æ˜¾ç¤ºä¸‹è½½é“¾æ¥è¾“å…¥æ¡†
        if (f.key === 'uris' && state.inlineEdit === 'uris') {
          const inputValue = state.inlineEditValue || '';
          const inputLine = '   ' + ANSI.secondaryText + 'â”Œâ”€' + ANSI.reset;
          const contentLine = '   ' + ANSI.secondaryText + 'â”‚ ' + ANSI.reset + ANSI.brightWhite + inputValue + ANSI.showCursor + ANSI.reset;
          const bottomLine = '   ' + ANSI.secondaryText + 'â””â”€ ' + ANSI.terminalGreen + 'Enter' + ANSI.reset + ANSI.secondaryText + ' ç¡®è®¤  ' + 'Esc' + ' å–æ¶ˆ' + ANSI.reset;
          lines.push(inputLine);
          lines.push(contentLine);
          lines.push(bottomLine);
        } else if (f.key === 'uris') {
          // æ˜¾ç¤ºå½“å‰å€¼ï¼ˆå¤šä¸ªURLï¼‰
          if (Array.isArray(cfg.uris) && cfg.uris.length > 0) {
            for (const uri of cfg.uris) {
              lines.push('     ' + ANSI.secondaryText + 'â€¢ ' + ANSI.reset + trunc(uri, cols - 7));
            }
          } else {
            lines.push('     ' + ANSI.secondaryText + '(æŒ‰ u æˆ– Enter è®¾ç½®ä¸‹è½½é“¾æ¥)' + ANSI.reset);
          }
        }
      } else {
        const labelPart = `${iconColor}${icon}${ANSI.reset} ${f.label}`;
        const valuePart = f.type !== 'bool' ? ` ${ANSI.secondaryText}:${ANSI.reset} ${coloredValue}` : '';
        lines.push(`   ${labelPart}${valuePart}`);
      }
    }

    // Bottom help with context
    lines.push('');
    lines.push(drawSeparator(cols, 'â”€', 'dim'));

    if (state.inlineEdit === 'uris') {
      lines.push(ANSI.primaryAccent + '  â„¹ è¾“å…¥ä¸‹è½½é“¾æ¥ï¼Œå¤šä¸ªé“¾æ¥ç”¨ç©ºæ ¼åˆ†éš”' + ANSI.reset);
    } else if (state.selected >= 0 && state.selected < groupFields.length) {
      const f = groupFields[state.selected];
      if (f.description) {
        lines.push(ANSI.primaryAccent + '  â„¹ ' + f.description + ANSI.reset);
      }
    } else {
      lines.push(ANSI.secondaryText + '  æŒ‰ Esc è¿”å›åˆ†ç»„åˆ—è¡¨  æŒ‰ s ä¿å­˜é…ç½®' + ANSI.reset);
    }

    // Message bar
    if (msg) {
      lines.push('');
      const msgColor = state.messageType === 'error' ? ANSI.errorRed :
                      state.messageType === 'success' ? ANSI.successGreen :
                      ANSI.primaryAccent;
      lines.push(msgColor + '  â„¹ ' + msg + ANSI.reset);
    }

    safeWrite(state.inlineEdit === 'uris' ? ANSI.showCursor : ANSI.hideCursor);
    safeWrite(ANSI.clear + ANSI.home);
    safeWrite(lines.join('\n'));
  }

  function renderPrompt() {
    const { cols, rows } = getTerminalSize();
    const label = state.prompt.label || 'Input';
    const hint = state.prompt.hint ? ` ${ANSI.secondaryText}(${state.prompt.hint})${ANSI.reset}` : '';

    const header = drawGroupHeader('ç¼–è¾‘è¾“å…¥', cols, 'section');
    const helpBar = '  ' + ANSI.terminalGreen + 'Enter' + ANSI.reset + ' ç¡®è®¤  ' +
                    ANSI.secondaryText + 'Esc' + ANSI.reset + ' å–æ¶ˆ  ' +
                    ANSI.secondaryText + 'Backspace' + ANSI.reset + ' åˆ é™¤';

    const lines = [];
    lines.push(header);
    lines.push(helpBar);
    lines.push(drawSeparator(cols, 'â”€', 'dim'));
    lines.push('');

    // Input field with box
    lines.push(ANSI.primaryAccent + '  ' + label + hint + ANSI.reset);
    lines.push('');
    const inputBox = [state.prompt.value || ANSI.secondaryText + '(ç©º)' + ANSI.reset];
    lines.push(...drawBox(inputBox, Math.min(cols - 4, 76)));

    // Validation feedback with semantic colors
    const validation = state.prompt.validation;
    if (validation && validation.message) {
      lines.push('');
      let icon = '';
      let color = '';
      if (!validation.valid) {
        icon = 'âœ—';
        color = ANSI.errorRed;
      } else if (validation.warning) {
        icon = 'âš ';
        color = ANSI.warningYellow;
      } else {
        icon = 'âœ“';
        color = ANSI.successGreen;
      }
      lines.push(color + `  ${icon} ` + validation.message + ANSI.reset);
    }

    safeWrite(ANSI.showCursor + ANSI.clear + ANSI.home);
    safeWrite(lines.join('\n'));
  }

  function renderPreview() {
    const { cols, rows } = getTerminalSize();
    const cmdArgs = buildArgsFromConfig(cfg);
    const lines = [];

    const title = 'å‘½ä»¤é¢„è§ˆ';
    lines.push(drawGroupHeader(title, cols));
    lines.push(trunc(ANSI.dim + 'Enter/r æ‰§è¡Œ  Esc è¿”å›  q é€€å‡º' + ANSI.reset, cols));
    lines.push('');

    // è¯­æ³•é«˜äº®çš„å‘½ä»¤è¾“å‡º
    const parts = [args.bin, ...cmdArgs];
    let cur = ANSI.brightYellow + parts[0] + ANSI.reset;
    for (let i = 1; i < parts.length; i++) {
      const part = parts[i];
      let coloredPart;
      if (part.startsWith('-')) {
        // æ ‡å¿—ç”¨ cyan é¢œè‰²
        coloredPart = ANSI.cyan + shellEscape(part) + ANSI.reset;
      } else {
        // å€¼ç”¨ white é¢œè‰²
        coloredPart = ANSI.white + shellEscape(part) + ANSI.reset;
      }

      const nextLen = stripAnsi(cur).length + 1 + stripAnsi(coloredPart).length;
      if (nextLen > cols - 2) {
        lines.push(trunc(cur, cols));
        cur = '  ' + coloredPart;
      } else {
        cur = cur + ' ' + coloredPart;
      }
    }
    if (cur) lines.push(trunc(cur, cols));

    lines.push('');
    lines.push(trunc(ANSI.dim + drawSeparator(cols) + ANSI.reset, cols));

    while (lines.length < rows) lines.push('');
    safeWrite(ANSI.hideCursor + ANSI.clear + ANSI.home + lines.slice(0, rows).join('\n'));
  }

  function render() {
    if (state.mode === 'confirm') renderConfirm();
    else if (state.mode === 'prompt') renderPrompt();
    else if (state.mode === 'preview') renderPreview();
    else renderList();
  }

  function renderConfirm() {
    const { cols, rows } = getTerminalSize();

    const header = drawGroupHeader('ç¡®è®¤æ“ä½œ', cols, 'section');
    const lines = [];
    lines.push(header);
    lines.push('');

    // Warning box with prominent styling
    const warningLines = [
      ANSI.warningYellow + 'âš  æ­¤æ–‡ä»¶å·²ä¸‹è½½å®Œæˆ' + ANSI.reset,
      '',
      'ç¡®å®šè¦é‡æ–°ä¸‹è½½å—ï¼Ÿ'
    ];
    lines.push(...drawBox(warningLines, Math.min(cols - 4, 60)));

    lines.push('');
    lines.push(drawSeparator(cols, 'â”€', 'dim'));
    lines.push('');

    // Action buttons with clear styling
    lines.push(ANSI.successGreen + '  [y] ' + ANSI.bold + 'æ˜¯' + ANSI.reset + ANSI.successGreen + ' - é‡æ–°ä¸‹è½½' + ANSI.reset);
    lines.push(ANSI.errorRed + '  [n] ' + ANSI.bold + 'å¦' + ANSI.reset + ANSI.errorRed + ' - å–æ¶ˆæ“ä½œ' + ANSI.reset);

    safeWrite(ANSI.hideCursor + ANSI.clear + ANSI.home);
    safeWrite(lines.join('\n'));
  }

  function beginPrompt(targetKey, label, hint, initialValue) {
    state.mode = 'prompt';
    state.prompt = {
      targetKey,
      label,
      hint: hint || '',
      value: String(initialValue ?? ''),
      validation: { valid: true, message: '' }
    };
    validatePromptValue();
    render();
  }

  function validatePromptValue() {
    const key = state.prompt.targetKey;
    const f = fields.find((x) => x.key === key);
    if (!f) return;
    const raw = state.prompt.value;

    // ç©ºå€¼æ€»æ˜¯æœ‰æ•ˆçš„ï¼ˆé™¤éå­—æ®µæ˜¯å¿…å¡«çš„ï¼Œä½†æˆ‘ä»¬è¿™é‡Œæ²¡æœ‰å¿…å¡«å­—æ®µï¼‰
    if (!raw || raw.trim() === '') {
      state.prompt.validation = { valid: true, message: '' };
      return;
    }

    if (f.type === 'number') {
      const v = Number(raw);
      if (!Number.isFinite(v)) {
        state.prompt.validation = { valid: false, message: 'å¿…é¡»æ˜¯æœ‰æ•ˆæ•°å­—' };
        return;
      }
      state.prompt.validation = { valid: true, message: 'âœ“ æœ‰æ•ˆæ•°å­—' };
      return;
    }

    if (f.type === 'string' && (f.key === 'dir' || f.key === 'torrentFile' || f.key === 'inputFile')) {
      if (fs.existsSync(raw)) {
        state.prompt.validation = { valid: true, message: 'âœ“ è·¯å¾„å­˜åœ¨' };
      } else {
        state.prompt.validation = { valid: true, message: 'âš  è·¯å¾„ä¸å­˜åœ¨ï¼ˆå°†åœ¨ä¸‹è½½æ—¶åˆ›å»ºæˆ–æŠ¥é”™ï¼‰', warning: true };
      }
      return;
    }

    if (f.key === 'maxDownloadLimit' || f.key === 'maxUploadLimit') {
      if (/^\d+[KMG]?$/i.test(raw)) {
        state.prompt.validation = { valid: true, message: 'âœ“ æ ¼å¼æ­£ç¡®' };
      } else {
        state.prompt.validation = { valid: false, message: 'æ ¼å¼é”™è¯¯ï¼Œåº”ä¸ºå¦‚ 10M, 1G, 500K' };
      }
      return;
    }

    state.prompt.validation = { valid: true, message: '' };
  }

  function cleanupTty() {
    try {
      safeWrite(ANSI.showCursor + ANSI.reset);
    } catch {}
    try {
      if (process.stdin.isTTY) process.stdin.setRawMode(false);
    } catch {}
  }

  async function runAria2c() {
    const cmdArgs = buildArgsFromConfig(cfg);
    if (!cmdArgs.some((x) => typeof x === 'string' && x.length > 0 && !x.startsWith('-')) && !cfg.torrentFile && !cfg.inputFile) {
      setMessage('æœªè®¾ç½®è¾“å…¥ï¼šæŒ‰ u å¡«é“¾æ¥ï¼Œæˆ–æŒ‰ t é€‰ç§å­ï¼Œæˆ–è®¾ç½®è¾“å…¥æ–‡ä»¶', 'warning');
      render();
      return;
    }

    // ä¿å­˜åˆ°å†å²è®°å½•
    const historyId = state.currentHistoryId || Date.now();
    addToHistory(cfg, 'pending');
    state.currentHistoryId = historyId;

    cleanupTty();
    safeWrite('\n');
    const child = spawn(args.bin, cmdArgs, { stdio: 'inherit' });
    child.on('exit', (code, signal) => {
      if (code === 0) {
        updateHistoryStatus(historyId, 'completed');
      } else {
        updateHistoryStatus(historyId, 'failed');
      }
      if (signal) process.exit(128);
      process.exit(code == null ? 1 : code);
    });
    child.on('error', (e) => {
      updateHistoryStatus(historyId, 'failed');
      // eslint-disable-next-line no-console
      console.error(String(e && e.message ? e.message : e));
      process.exit(1);
    });
  }

  function saveConfig() {
    const toSave = { ...cfg };
    writeJson(args.config, toSave);
    setMessage(`å·²ä¿å­˜ï¼š${args.config}`, 'success');
  }

  function toggleField(f) {
    if (f.type !== 'bool') return;
    cfg[f.key] = !cfg[f.key];
  }

  function bumpEnum(f) {
    if (f.type !== 'enum' || !Array.isArray(f.options)) return;
    const cur = String(cfg[f.key] || '');
    const idx = f.options.indexOf(cur);
    cfg[f.key] = f.options[(idx + 1) % f.options.length];
  }

  function applyPromptValue() {
    const key = state.prompt.targetKey;
    const f = fields.find((x) => x.key === key);
    if (!f) return;
    const raw = state.prompt.value;
    if (f.type === 'number') {
      const v = Number(raw);
      if (!Number.isFinite(v)) {
        setMessage('æ•°å­—æ ¼å¼ä¸æ­£ç¡®', 'error');
        return;
      }
      cfg[key] = v;
      return;
    }
    if (f.type === 'bool') {
      cfg[key] = raw === 'true' || raw === '1' || raw === 'yes' || raw === 'on';
      return;
    }
    if (f.type === 'list') {
      cfg[key] = String(raw || '')
        .trim()
        .split(/\s+/)
        .filter(Boolean);

      // å¦‚æœæ˜¯è¾“å…¥æºå­—æ®µï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ•ˆå¹¶è‡ªåŠ¨è¿”å›
      if (f.group === 'input' && state.currentGroup === 'input') {
        checkInputSource();
        if (state.inputSourceSet) {
          autoExtractFilename();
          // å»¶è¿Ÿä¸€å¸§åè¿”å›åˆ†ç»„èœå•ï¼Œè®©ç”¨æˆ·çœ‹åˆ°æˆåŠŸæç¤º
          setTimeout(() => {
            exitGroup();
          }, 100);
        }
      }
      return;
    }

    // å­—ç¬¦ä¸²ç±»å‹å­—æ®µ
    cfg[key] = String(raw);

    // å¦‚æœæ˜¯è¾“å…¥æºå­—æ®µï¼Œæ£€æŸ¥æ˜¯å¦æœ‰æ•ˆå¹¶è‡ªåŠ¨è¿”å›
    if (f.group === 'input' && state.currentGroup === 'input') {
      checkInputSource();
      if (state.inputSourceSet) {
        autoExtractFilename();
        // å»¶è¿Ÿä¸€å¸§åè¿”å›åˆ†ç»„èœå•ï¼Œè®©ç”¨æˆ·çœ‹åˆ°æˆåŠŸæç¤º
        setTimeout(() => {
          exitGroup();
        }, 100);
      }
    }
  }

  function restoreFromHistory() {
    if (state.selected === 0 || history.length === 0) {
      // æ–°å»ºä¸‹è½½
      state.view = 'groups';
      state.selected = 0;
      checkInputSource();
      if (!state.inputSourceSet) {
        state.view = 'fields';
        state.currentGroup = 'input';
        state.selected = 0;
      }
      render();
      return;
    }

    const h = history[state.selected - 1];
    if (!h) return;

    // å¦‚æœå·²å®Œæˆï¼Œè¯¢é—®æ˜¯å¦é‡æ–°ä¸‹è½½
    if (h.status === 'completed') {
      state.mode = 'confirm';
      state.confirmAction = () => {
        loadConfigFromHistory(h);
        state.mode = 'list';
      };
      state.confirmCancel = () => {
        state.mode = 'list';
        render();
      };
      render();
      return;
    }

    // æœªå®Œæˆæˆ–å¤±è´¥çš„ï¼Œç›´æ¥æ¢å¤
    loadConfigFromHistory(h);
  }

  function loadConfigFromHistory(h) {
    Object.assign(cfg, h.config);
    state.currentHistoryId = h.id;
    checkInputSource();
    state.view = 'groups';
    state.selected = 0;
    setMessage(`å·²æ¢å¤ä¸‹è½½: ${h.filename}`, 'success');
    render();
  }

  function deleteHistoryEntry() {
    if (state.selected === 0 || history.length === 0) return;
    const idx = state.selected - 1;
    if (idx >= 0 && idx < history.length) {
      history.splice(idx, 1);
      saveHistory();
      if (state.selected > history.length) {
        state.selected = history.length;
      }
      setMessage('å·²åˆ é™¤å†å²è®°å½•', 'info');
      render();
    }
  }

  function beginEditSelected() {
    if (state.view === 'history') {
      // åœ¨å†å²è®°å½•è§†å›¾ä¸­ï¼ŒEnter æ¢å¤ä¸‹è½½
      restoreFromHistory();
    } else if (state.view === 'groups') {
      // åœ¨åˆ†ç»„è§†å›¾ä¸­ï¼ŒEnter è¿›å…¥åˆ†ç»„
      enterGroup();
    } else {
      // åœ¨å­—æ®µè§†å›¾ä¸­ï¼ŒEnter ç¼–è¾‘å­—æ®µ
      const groupFields = fields.filter(f => f.group === state.currentGroup);
      const f = groupFields[state.selected];
      if (!f) return;
      if (f.type === 'action' && f.key === '__run__') {
        runAria2c();
        return;
      }
      if (f.type === 'bool') {
        toggleField(f);
        return;
      }
      if (f.type === 'enum') {
        bumpEnum(f);
        return;
      }

      // ç‰¹æ®Šå¤„ç†ï¼šä¸‹è½½é“¾æ¥å­—æ®µä½¿ç”¨å†…è”ç¼–è¾‘
      if (f.key === 'uris') {
        const current = Array.isArray(cfg.uris) ? cfg.uris.join(' ') : '';
        state.inlineEdit = 'uris';
        state.inlineEditValue = current;
        render();
        return;
      }

      // ç‰¹æ®Šå¤„ç†ï¼šæ–‡ä»¶å­—æ®µæ‰“å¼€æ–‡ä»¶æµè§ˆå™¨
      if (f.type === 'file') {
        beginFileBrowser(f.key);
        return;
      }

      const current = f.type === 'list' ? (Array.isArray(cfg[f.key]) ? cfg[f.key].join(' ') : '') : formatValue(cfg[f.key]);
      beginPrompt(f.key, f.label, f.hint, current);
    }
  }

  function enterGroup() {
    if (state.selected < 0 || state.selected >= groupDefinitions.length) return;
    const group = groupDefinitions[state.selected];

    // æ£€æŸ¥æ˜¯å¦éœ€è¦å…ˆè®¾ç½®è¾“å…¥æº
    if (group.key !== 'input' && !state.inputSourceSet) {
      setMessage('è¯·å…ˆè®¾ç½®è¾“å…¥æºï¼ˆä¸‹è½½é“¾æ¥ã€ç§å­æ–‡ä»¶æˆ–è¾“å…¥æ–‡ä»¶ï¼‰', 'warning');
      render();
      return;
    }

    state.view = 'fields';
    state.currentGroup = group.key;
    state.selected = 0;
    render();
  }

  function exitGroup() {
    const wasInInputGroup = state.currentGroup === 'input';

    // æ£€æŸ¥è¾“å…¥æºè®¾ç½®
    const wasSet = state.inputSourceSet;
    checkInputSource();

    // å¦‚æœåˆšä»è¾“å…¥æºåˆ†ç»„é€€å‡ºï¼Œè‡ªåŠ¨å°è¯•ä» URL æå–æ–‡ä»¶å
    if (wasInInputGroup && state.inputSourceSet && !cfg.out) {
      autoExtractFilename();
    }

    // å¦‚æœæ˜¯ä»è¾“å…¥æºè¿”å›ä¸”åˆšåˆšè®¾ç½®æˆåŠŸï¼Œæ˜¾ç¤ºæç¤º
    if (wasInInputGroup && !wasSet && state.inputSourceSet) {
      setMessage('âœ“ è¾“å…¥æºå·²è®¾ç½®ï¼Œå…¶ä»–åˆ†ç»„å·²è§£é”', 'success');
    }

    state.view = 'groups';
    state.currentGroup = null;
    state.selected = 0;
    render();
  }

  function autoExtractFilename() {
    if (Array.isArray(cfg.uris) && cfg.uris.length > 0) {
      const firstUri = cfg.uris[0];
      try {
        const url = new URL(firstUri);
        const pathname = url.pathname;
        const filename = pathname.split('/').pop();
        if (filename && filename.length > 0 && filename.includes('.')) {
          cfg.out = decodeURIComponent(filename);
          setMessage(`å·²è‡ªåŠ¨æå–æ–‡ä»¶å: ${cfg.out}`, 'info');
        }
      } catch {
        // URL è§£æå¤±è´¥ï¼Œå¿½ç•¥
      }
    }
  }

  function beginFileBrowser(targetKey) {
    // TODO: å®ç°å®Œæ•´çš„æ–‡ä»¶æµè§ˆå™¨åŠŸèƒ½
    // æš‚æ—¶ä½¿ç”¨ä¼ ç»Ÿçš„promptæ–¹å¼
    const label = targetKey === 'torrentFile' ? 'Torrent æ–‡ä»¶è·¯å¾„' : 'è¾“å…¥æ–‡ä»¶è·¯å¾„';
    const currentValue = cfg[targetKey] || '';
    beginPrompt(targetKey, label, 'æ–‡ä»¶è·¯å¾„', currentValue);
  }

  function onKey(buf) {
    const s = buf.toString('utf8');

    if (s === '\u0003') {
      cleanupTty();
      safeWrite('\n');
      process.exit(0);
    }

    // å¤„ç†å†…è”ç¼–è¾‘æ¨¡å¼
    if (state.inlineEdit === 'uris') {
      if (s === '\x1b') {
        // Esc å–æ¶ˆç¼–è¾‘
        state.inlineEdit = null;
        state.inlineEditValue = '';
        render();
        return;
      }
      if (s === '\r' || s === '\n') {
        // Enter ç¡®è®¤
        const value = state.inlineEditValue.trim();
        if (value) {
          cfg.uris = value.split(/\s+/).filter(u => u.length > 0);
          checkInputSource();
          if (state.inputSourceSet) {
            autoExtractFilename();
          }
          setMessage('âœ“ ä¸‹è½½é“¾æ¥å·²è®¾ç½®', 'success');
        } else {
          cfg.uris = [];
          checkInputSource();
        }
        state.inlineEdit = null;
        state.inlineEditValue = '';

        // è‡ªåŠ¨è¿”å›åˆ†ç»„èœå•
        if (state.inputSourceSet && state.currentGroup === 'input') {
          setTimeout(() => {
            exitGroup();
          }, 100);
        }
        render();
        return;
      }
      if (s === '\x7f') {
        // Backspace åˆ é™¤å­—ç¬¦
        state.inlineEditValue = state.inlineEditValue.slice(0, -1);
        render();
        return;
      }
      if (s >= ' ' && s <= '~') {
        // å¯æ‰“å°å­—ç¬¦
        state.inlineEditValue += s;
        render();
        return;
      }
      return;
    }

    if (state.mode === 'confirm') {
      if (s === 'y' || s === 'Y') {
        if (state.confirmAction) state.confirmAction();
        return;
      }
      if (s === 'n' || s === 'N' || s === '\x1b') {
        if (state.confirmCancel) state.confirmCancel();
        return;
      }
      return;
    }

    if (state.mode === 'prompt') {
      if (s === '\x1b') {
        state.mode = 'list';
        render();
        return;
      }
      if (s === '\r' || s === '\n') {
        applyPromptValue();
        state.mode = 'list';
        render();
        return;
      }
      if (s === '\x7f') {
        state.prompt.value = state.prompt.value.slice(0, -1);
        validatePromptValue();
        render();
        return;
      }
      if (s >= ' ' && s <= '~') {
        state.prompt.value += s;
        validatePromptValue();
        render();
      }
      return;
    }

    if (state.mode === 'preview') {
      if (s === '\x1b') {
        state.mode = 'list';
        render();
        return;
      }
      if (s === 'q') {
        cleanupTty();
        safeWrite('\n');
        process.exit(0);
      }
      if (s === '\r' || s === '\n' || s === 'r') {
        runAria2c();
      }
      return;
    }

    // list mode
    if (s === 'q') {
      cleanupTty();
      safeWrite('\n');
      process.exit(0);
    }

    if (s === '\x1b[A' || s === 'k') {
      // ä¸Šé”®
      if (state.view === 'history') {
        state.selected = Math.max(0, state.selected - 1);
      } else if (state.view === 'groups') {
        state.selected = Math.max(0, state.selected - 1);
      } else {
        const groupFields = fields.filter(f => f.group === state.currentGroup);
        state.selected = Math.max(0, state.selected - 1);
      }
      render();
      return;
    }

    if (s === '\x1b[B' || s === 'j') {
      // ä¸‹é”®
      if (state.view === 'history') {
        const maxIdx = history.length; // +1 for "new download" option
        state.selected = Math.min(maxIdx, state.selected + 1);
      } else if (state.view === 'groups') {
        state.selected = Math.min(groupDefinitions.length - 1, state.selected + 1);
      } else {
        const groupFields = fields.filter(f => f.group === state.currentGroup);
        state.selected = Math.min(groupFields.length - 1, state.selected + 1);
      }
      render();
      return;
    }

    if (s === '\x1b') {
      // Esc é”®ï¼šè¿”å›ä¸Šä¸€å±‚
      if (state.view === 'fields') {
        exitGroup();
      } else if (state.view === 'groups') {
        state.view = 'history';
        state.selected = 0;
        render();
      }
      return;
    }

    // å†å²è®°å½•è§†å›¾ç‰¹æœ‰çš„é”®
    if (state.view === 'history') {
      if (s === 'n' || s === 'N') {
        // æ–°å»ºä¸‹è½½
        state.view = 'groups';
        state.selected = 0;
        checkInputSource();
        if (!state.inputSourceSet) {
          state.view = 'fields';
          state.currentGroup = 'input';
          state.selected = 0;
        }
        render();
        return;
      }
      if (s === 'd' || s === 'D') {
        // åˆ é™¤å†å²è®°å½•
        deleteHistoryEntry();
        return;
      }
    }

    if (s === ' ') {
      if (state.view === 'fields') {
        const groupFields = fields.filter(f => f.group === state.currentGroup);
        const f = groupFields[state.selected];
        if (f && f.type === 'bool') {
          toggleField(f);
          render();
        }
      }
      return;
    }

    if (s === 'u') {
      // å¿«æ·é”®ï¼šç›´æ¥è¿›å…¥è¾“å…¥æºè®¾ç½® URIs
      if (state.view === 'groups') {
        state.view = 'fields';
        state.currentGroup = 'input';
        state.selected = 0;
        // è‡ªåŠ¨æ¿€æ´»å†…è”ç¼–è¾‘
        const current = Array.isArray(cfg.uris) ? cfg.uris.join(' ') : '';
        state.inlineEdit = 'uris';
        state.inlineEditValue = current;
        render();
      } else if (state.currentGroup === 'input') {
        // åœ¨è¾“å…¥æºåˆ†ç»„ä¸­ï¼Œæ¿€æ´»å†…è”ç¼–è¾‘
        const current = Array.isArray(cfg.uris) ? cfg.uris.join(' ') : '';
        state.inlineEdit = 'uris';
        state.inlineEditValue = current;
        render();
      }
      return;
    }

    if (s === 't') {
      // å¿«æ·é”®ï¼šç›´æ¥è¿›å…¥æ–‡ä»¶é€‰æ‹©
      if (state.view === 'groups') {
        state.view = 'fields';
        state.currentGroup = 'input';
        state.selected = 1; // é€‰æ‹©æ–‡ä»¶å­—æ®µ
        render();
      } else if (state.currentGroup === 'input') {
        // åœ¨è¾“å…¥æºåˆ†ç»„ä¸­ï¼Œæ‰“å¼€æ–‡ä»¶æµè§ˆå™¨
        const groupFields = fields.filter(f => f.group === state.currentGroup);
        const fileField = groupFields.find(f => f.type === 'file');
        if (fileField) {
          beginFileBrowser(fileField.key);
        }
      }
      return;
    }

    if (s === 'p') {
      state.mode = 'preview';
      render();
      return;
    }

    if (s === 's') {
      try {
        saveConfig();
      } catch (e) {
        setMessage(`ä¿å­˜å¤±è´¥: ${String(e && e.message ? e.message : e)}`, 'error');
      }
      render();
      return;
    }

    if (s === 'r') {
      runAria2c();
      return;
    }

    if (s === '\r' || s === '\n') {
      beginEditSelected();
      render();
    }
  }

  process.stdin.setEncoding('utf8');
  process.stdin.setRawMode(true);
  process.stdin.resume();
  process.stdin.on('data', (d) => onKey(Buffer.from(d)));

  process.on('SIGWINCH', () => render());
  process.on('SIGINT', () => {
    cleanupTty();
    safeWrite('\n');
    process.exit(0);
  });

  // åˆå§‹åŒ–ï¼šæ£€æŸ¥è¾“å…¥æºçŠ¶æ€
  checkInputSource();

  // é»˜è®¤æ˜¾ç¤ºå†å²è®°å½•è§†å›¾
  state.view = 'history';
  state.selected = 0;

  render();
}

main().catch((e) => {
  try {
    safeWrite(ANSI.showCursor + ANSI.reset + '\n');
  } catch {}
  // eslint-disable-next-line no-console
  console.error(String(e && e.stack ? e.stack : e));
  process.exit(1);
});
